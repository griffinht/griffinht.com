me!
https://paulgraham.com/own.html

There are occasionally times when schoolwork becomes a project of one's own. Whenever I had to write a paper, that would become a project of my own â€” except in English classes, ironically, because the things one has to write in English classes are so bogus. And when I got to college and started taking CS classes, the programs I had to write became projects of my own. Whenever I was writing or programming, I was usually skating, and that has been true ever since.


# A personal computing history

ok this has gone off the rails lmao turns out its just gonna be a list of everything

Specifically, a personal history of interactions with computers.

# 2007? The beginning

idk if this counts?

prek tots for kids got me in to computer games i think. I would be sit in the hallway with the person (lady? tutor? instructor) on a laptop (todo insert image approximation) (with a CDROM drive) and play computer games. This was where I was introduced to a few different CDROM games. My favorites included [Wild Wheels](https://archive.org/details/wild-wheels-pc), inventive machine crazy machine? (was it?) and [Speedy Eggbert](https://www.blupi.org/) (now open source)!

I distinctly a time while playing Wild Wheels, where I was driving around a world with mountains and lava, and managed to take a brief dip in the lava. This caused my wheels to pop in the game

Wild Wheels had destruction physics and effects! Parts would fly off the vehicle everytime it collided with a wall, and sparks would fly while scraping across metal.

mom's iphone 4 in the pink otterbox case playing PvZ and fruit ninja and jetpack joyride

Minecraft ipod touch 2nd grade

minecraft envy laptop 3rd grade

school computer lab
    these machines were running windows XP, with a small subset running Windows 7. We sat according to our last name, and the beginning of the alphabet got upgraded to windows 7.
    elementary school - outlook/ ms online
        i remember that the command prompt was disabled, but i could bypass the restricition by writing a `.BAT` batch script in notepad, then running it.
            this allowed me to CD and DIR around the computer. i even found the users directory \\Users? which showed me a list of every student who had logged in to that machine - i felt like such a hacker!
            this was also the time of using an easily guesssable incrementing student id, and student ids were everyones password
                the first 4 digits of most people in our class was `1203` or `1204`, and the last 4 digits were public as part of everyone's email
        computer carts, first 10 minutes of class to log in to windows
    middle school - google drive
        chromebook era, instant login, google drive - no more files lost on the desktop (no matter how many times the technology teacher told us to use our network drives)
        covid then bring your own laptop (or take home chromebook), google drive
        google drive brought the source:domain trick, allowing me to browse every publicly shared document across the district - neat! if your org uses google drive, consider adding source:domain to the search bar, it seems to be seldom disabled

minecraft
    mods
        youtube mod installation tutorials,
            winrar!
        adfly skip ad links to mediafire downloads
    planetminecraft world downloads
    flan's mod, optifine
    pull up old recoridings
        "free no watermark recorder"
            obs existed, but I didn't know about it
            my internet search capabilities were type in to the address bar, click the first three linsk
        bandicam!

minecraft server 4th grade, skype with friends
    the first version of minecraft i played was 1.4.5. i remember the first thing i did was hop in to create and find a mineshaft - amazing!
        cue endless summer nights of c418 and chill - mining and crafting the summer nights away (link to mc music)
    this began my career of system administration
    My friends and I talked to each other after school on Skype, where we would find Minecraft servers to play on together. Favorites included the giants like Hypixel (still going strong), shotbow networks for minez, cubecraft?, and a bit of mineplex. We would also frequent smaller servers, craving the survival multiplayer experience. We mostly and a1craft (ecocraft?), the og prison server (a1?? see ssundee), towny? what early towny did i dO? YouTubers were a huge influence on how I played Minecraft - EthosCraft was probably my favotite. paulsoresjr taught me how to play, and og redstoners?
    following a youtube 
    whenever I wanted to play with my friends

monkeyquest 3rd grade? why did i play it on moms laptop
poptropica
coolmathgames
always a challenge to find unblocked games - coolmathgames was never blocked!

Clash of clans 5th grade

"gaming" pc summer of 6th grade

Clash royale 6th grade

I remember how everyone was so impressed (including myself) that I had built an entire computer. All I had done was insert some components and plug in a few cables. This allowed me to finally run Minecraft at blazing fast speeds on my GTX 950 graphics card. The Minecraft server hosting continued and from 6th to 7th grade I ran DreadedMC todo web archive?, wh. This was when I went pro, going from server hosting on



The family computer was my first foray in to the magical digital world. It ran Windows XP, with the green start menu button. This was when I watched shows like [Cyberchase](link to youtube vid) on PBS kids with the ol' tube TV (my family's first flatscreen TV was an LED model around 2010, skipping the plasma era and going straight to RGB?).I enjoyed playing CDROM games rented from the library, and flash games on the web. 

I esp

that construction game where you could run in to the bathroom and the guy would say im in here.

# The earliest days

The first programming I remember doing was a bit of JavaScript around 4th grade. I wanted to learn to code for some reason - why did I want to learn to code?

I probably fired up the ol' internet explorer? was i using chrome at the time

# The early days

# The Minecraft days

Neovim or NeoVim
eclipse (old)
intellij (proprietary improved eclipse)

I used to be an Intellij - it provided the best IDE experience I ever had. I used Eclipse beforehand and always thought of it as a clunky 2000s era relic of the past. IntelliJ blew me away with Intellisense. To clarify, my development had been the default notes, then Notepad++ (I thought it had good syntax highlighting, and multiple tabs were nice). Eclipse's tab management was annoying

Now I manage my "tabs" with my tiling window manager. Any app. I remember when Chrome's tab groups came out, and I thought they were such a great way to organize my pesky tabs. Now I barely use tabs in my browser, and instead try to keep one tab per window. This is the same with my text editor.

If I wanted to manage my Intellij or Eclipse (or VSCode) buffers with my window manager, then I couldn't! Even NeoVim, which seems to have excellent window management, I still try to keep one split open at a time, and may have several instances. This has been a struggle with Language Server integrations, where I might have several servers fr the same project running at once. This is not efficient and can break many servers. Additionally, each time I open a file I have to wait for the language server to start up. I am looking to be able to configure Neovim to use one language server per project, and reuse the language server from multiple NeoVim clients. todo

The other issue I have is editing the same file from two different editors. I often see the "you already have this file open in a different instance" warning and will then have to find the instance or blah. This is an issue when I am using language server code navigation, and want to jump to the definition of a function which is definined in a different file already open in a different NeoVim instance.


# tabs todo split to other article
Anyways any app that attempts to . I sometimes see new "web browsers" (chrome/chromoum/todo wrappers) which aim to reimagine the browsing experience by implementing some form of advanced

I also stopped using dual or even triple monitors after my 

I began using dual monitors a while ago for gaming, which allowed me to have the game on one screen and Discord or a web browser with a map or a wiki page pulled up for reference. I then extended this for work - I could have my text editor on one screen with a document on the other, saving me from having to switch between the two. Technically, I could have simply 

IDEs are ginourmous space hogs. They always needed an entire rectangular screen, and would become unusable if given less space

show example of full screen vs half screen eclipse/intellij

This made me realize how useful a dual monitor setup could be with programming - IDE on one screen, reference document (web search, documentation, code snippets) on the other. todo use regular language like google and stackoverflow and more recently ChatGPT.

# Summer 2022

    homelabbin!

# Fall 2022

    settling in to college

216/226
Intro to java and a math class

# Spring 2023
    
    more guix, more sway, more neovim, more lf, no ides

316 and 230 and physics python scripts

In my physics I class, every homework I did was a python script. I only used a "normal" calculator on the exams (which was incredibly annoying). My instructor, Dr. Titus, was actually also on board. Dr. Titus show physics demos written in python in class. He even mentioned how he was looking to allow using python on the tests (but hadn't, due to the logistical challenge of having access to a computer on an exam).

I started using NeoVim for simple text editing only. I knew there were ways to make it more useful for "real" programming 

NeoVim began as a better Notepad++ for me - the modal text editing was an improvement over the "regular" standard todo single mode editing provided by Notepad++. I liked the this way so much that I installed the Vim plugin in IntelliJ. I remember thinking how my programming 

NeoVim + IntelliJ with the vim plugin served me well for a while. I used NeoVim alongside `lf`, my terminal based file manager. This allowed me to browse files with my keyboard, then instantly e. This served my programming needs very well at the time. I was mostly programming school projects in Java and C. 

I was mostly experimenting with Docker at this time, managing my services todo link. This environment tended to have extremely long feedback loops - I would edit some kind of `.yml` or `Dockerfile` then run a command to rebuild or redeploy or re whatever my changes. Most of the work was reading documentation or configuring things. This meant the only needs I had for my developer tools were the ability to edit files, which were fulfilled completely with `lf` + NeoVim.

# Summer 2023

    linear and stats

Linear Algebra . I got carried away. This again served as a handicap on the exam (is handicap the right word here? todo). I spent much of the paper and pencil (and [stupid non graphing calculator](link to calc)) exams attempting to find the elementary school level mistake I had made manually adding and multiplying numbers together. Contrast this to my homeworks and python scripts. I would get carried away implementing my own matrix the matrix operations 

todo link to the scripts! and consider how you could make a demo

Stats was a drag, but it was mostly painless. I suppose I could have gotten a lot more out of the class if I did all the work in an interactive data analysis environment like R or even python. I instead scraped by with the same TI-84+ that got me through high school AP Statistics (which was essentially the same class I was taking now, but the credit transferred for ST 32222 which I did not need).

# Fall 2023

    326 and 246 and 481 network sec

this was a bad semester

I eventually found my needs were shifting, and I began demanding more from my development environment. My university C programming classes fueled this need. I would see my classmates using VSCode to debug their C programs, just like I debugged my Java programs in IntelliJ. I had been getting by with good 'ol `gdb`, but wanted more. Code navigation, improved syntax highlighting, and an actual debugging environment were all things I was looking for. It wasn't until midway through my 3rd semester (Fall 2023) that I got these things working.

It started with language servers. The built in syntax highlighting for NeoVim was fine for certain things, but completely fell apart when compared to IntelliJ's Java syntax highlighting. This was mostly fine for a while, because I would simply use Eclipse for bruh [CSC 326](todo link) had me writing a Java program. The 

This was also the time that I had had enough with Eclipse. 

I never saw C as a language which required all the . I got used to the edit-save-compile workflow, with a shell REPL in one

CSC 326 pitted teams of 5 students against the software requirements. The software was simple - a Spring Boot web app call "CoffeeMaker" which was supposed to represent a coffee shop ERP system. Ingredients could be defined, inventory could be stocked, drink recipes could be created and made, depleting the inventory. We had to implement a multi user customer order system. I remember getting lost in the Spring Security documention in an effort to support employee login and "anonymous" ordering features. The whole thing was a huge mess throughout the semester, and a sizable amount of time was spent waiting for . Sometimes we had to restart the entire Sprint Boot server to see a change in the HTML files. This was when Eclipse was working, which it often was not. Unexplainable errors plauged the entire team, with the fix usually being delete the project and restart Eclipse. I mostly fixed everything by replacing Eclipse with Neovim using `nvim-jdtls` and the Eclipse language server (which is seriously not buggy at all compared to Eclpise).

# Winter 2023

cringe:
Having left the dumpster fire of the fall semester behind me, I was finally able to pursue my personal projects again.

It was only after I completed the semester that I realized how much of my time and energy had been sapped away from me. Thanks to I had an entire month of rest and relaxation, which gave me a chance to pick up all the things I put on pause. I began programming for fun again - not that I didn't enjoy the programming projects of the previous semester, but that I finally had the chance to work on something that was not school related. It was a breath of fresh air being able to start and stop a project on a whim, and only work on what interested me the most rather than of the thing that was due at 11:59. It was also at this time that I realized the last time I open Steam had been exactly one year ago, which gave me mixed feelings. I ended up playing a bit of Minecraft, BeamNG.drive, and Escape from Tarkov with some friends, and thoroughly enjoyed it. It reminded me of the bliss of gaming away endless afternoons and weekends. reword prev sentence todo

# Spring 2024

    333

CSC 333, my automata class, . I'd like to implement the automatons in some kind of Lisp - Scheme? Maybe Guile? [todo link to repo](). The course is taught by [Dr. Jennings](https://jamiejennings.com/), and has so far been an absolute treat. Many of my other computer science professors have focused on teaching.

My Intro to AI course is neat. We are currently programming a cleaning bot which looks something like this: insert figure todo. The language is Java [1](footer?idk), and I am looking to use [`nvim-jdtls`](todo) to sprinkle some interactive programming in to my robot programming workflow. `nvim-jdtls` implements hot code reloading and JShell, Java's REPL (which I did not realize existed!). I'd like to see how "powerful" I can get my workflow to become - the current workflow consists of long running visual testing with the robot running around according to my algorithm. I'd like to be able to modify the algorithm while the robot is running.

insert a gif?

[1] Java (and Eclipse) are NC State's language of choice for the core required CS courses: [intro to programming](todo), [software engineering princieples](todo), [data structures](todo), [software engineering](todo). The C language is sprinkled in to the two required systems classes - csc 230 and csc 246, but the "standard" tooling is Java and Eclipse.






it could be more useful Once I configured using NeoVim for "real" programming (programming which requires "intellisense" and debugging)


i am beginning an explosion of new ways to solve my problems, and new problems to solve
https://paulgraham.com/avg.html

im increasing my power level!
    the computer is the thing that lets me play the cdrom games
    the computer is the thing that lets me play the pc games and talk to my friends
    programs are the things i need to get to play my games and talk to my friends
    files are the things i need to download from mediafire to get my minecraft mods
    servers are the things that my friends and i can play on together
    i can use someone elses or make my own server
        then i can set my own rules
        i can pick the minecraft version
        i can pick the environment - it could be my computer, and only be online when i am playing
            or it can be in someone else's environment, but still my server - hosted servers
    port forwarding is the thing that lets my friends (and maybe hackers) connect to my computer from their computers
    ip addresses and ports are the things my friends
    professional servers use domains instead of ip addresses, and don't need a port
    shared servers need a port because there are many servers at the same ip address
    computers are built by engineers and scientists and their robots soldering tiny components to green board
    computers are no more complex than a lego set (and i loved legos) - you just have to take the pieces and put them together
    the specs of a computer are very important - there is the cpu and gpu and ram and the combination of all three 
    steam games - my cable coax internet is very slow, and downloading a game requires hours
    uploading is even slower, and i will never be a "streamer" (nor was anyone else) - and uploading videos to youtube took forever
    when the wifi breaks its could be a variety of factors
        it comes in through the house with the same cable as our tv
        sometimes the box needs to be rebooted
    inspect element - all the websites i use written in code, and i can even change the code to prank my friends
    web search

developer tools
    text editor
    copilot - see ai 2.0

programming
    i can inspect element to edit websites
    websites are made up of code
    i can write my own code
    "how to learn to code" -> codeacademy.com
        html, css, javascript in a web ide (what were they called back then)
    i can make my own websites by writing html code with a bit of css, and don't need a visual "website builder"
    i can make interactive websites with javascript
    now im programming!
    i can analyze my code with browser devtools
    i can debug my code with console.log() and the console
        technicaly my first foray in to interactive programming
    i can debug my code with a breakpoint debugger
    programming is a spectrum
        static - turing
            statically typed
            write test methods, verify 
            java (gc, virtual machine) -> c (machine code) -> assembly -> x86? -> turing machine
        dynamic - lamba
            dynamically typed, can still support docstring type hints or even typescript 
            javascript/python (gc, virtual runtime, interpreted) -> lisp -> lambda calculus

concurrency
higher order functions
memory safety
    java map/reduce
        trie implementation taught me these silly syntax hacks were 
    java/c/c++ multithreading
        i can run multiple things at once and there are data races
        multithreading is faster than single threading which is why its good to split program into threads and syncrhonize them
            game loop: input loop, physics loop, render loop, network loop
                separate thread for each, then they talk to each other
                syncrhonization/concurrency/locks/mutexes/race conditoins are a pita
                    but i think elixir magically solves these problems somehow but idk
    rust data first real speed/performance
            game loop: key/network input, physics loop, render loop, network loop
            syncrhonization/concurrency/locks/mutexes/race conditoins are a solved problem
                    elixir solves this with actors
                    rust solves this with borrow checking
                        turns out memory safety is a solved problem and c and c++ are stupid

dependencies, supply chain
    first there were virtual machines, then there were containers
    package managers
        who knew installing 
            windows had me running executable installers, half installed programs, unsinstallers all over the place
    init systems
        windows had the services tab but it kind of sucked
    containers solve everything, put everything in to a docker container
    install as little as possible on the host (debian apt or arch paru)
    language package managers (npm, maven) are usually stupid and annoying
    system package managers barely have any sofware
    arch is a better and faster debian and aur has all the software
    alpine is a lean and slim debian, great for containers
    nix? nix shell? some useless tool that lets you install software with environment variables or something instead of system wide
    i want to use sway which means i need a bunch of small programs which arent packaged - time to switch to arch?
    all these packages are annoying and i have so many now how can i keep track of them all without just brittle shell scripts?
    enter guix home - it manages dotfiles too! neat!
    guix home all the programs and install nothing to the host - just like when i discovered docker
    this guix thing is great i wish i could make my own packages but guix is confusing and hard
    lispin.... here we go
    all package managers are less powerful than guix and nix
    guix (and nix) is the last package manager/vm creator/image creator/dockerfile i will ever need
        apt sucks
        pacman sucks less and aur is nice
        docker is also nice
        but guix? does everything - literally everything
    supply chain is important and hard on npm -> supply chain is a solved problem (guix) (ok obviosuly guix can stil have issues but it solves (or will solve) basically every supply chain problem)
    bootstrappability is important! binaries are bad
        vendoring packages in package distributions is silly
        vendoring packages in java jars is awful
        unnecesary static linking is no good!
        vendoring packages in git is awful

bootloaders
    debian/windows dual bool
        when linux wont boot its beacuse the bootloader is broken
        read the debian wiki and pray that grub-install fixes things
    arch
        turns out we don't even need grub and can just boot straigth to the terminal efistub
    uefi/bios boot
    guix
        grub is nice and easy to add entries to - it can even boot windows no more akward bios selection
        grub is extensible and can be used by your system to do rollbacks and stuff! neat!

dns 
    when i join my friends minecraft server i type in the ip address
    but professional servers have urls i type in
    turns out i can make my own domain and then no more akward ip addresses
    dns records can have more than A records ipv6, txt, mail, mail securitry (dkim spf whatever)

networking/routing
    port forwarding is the thing i do to let my friends in to my home network
    i have to be on the same network for lan games to work - often doesn't work in hotels and airports but home is fine
    openvpn
    mikrotikkin'
    linux networking
    wireguard - so many topologies! a vpn isn't just the thing that lets you bypass content restrictions

personal files documents
    google drive, collaborative editing - better than
    collaborative editing - gdrive still king, still need to find a good oss alternative
    google drive ties you to the web and unempoweres users and their files
    suddenly everything is a service even the things that werent services before
    everyone should have a personal sync/file server solution - even a hosted one
        and they should use that rather than gdrive/airdrop/email for file sharing

information/research
    there are several sources of information
    books, newspapers, magazines, radio, textbooks, and the web
    the web (google) is the best source of information for discovering new informatoin, but if you want to be an epert on a topic you should really find a good book
        i enjoyed reading programming books - html5 and css3 for dummies, and those jquery javascript books from that era of web dev
    the other sources of information are only used when the teacher says you have to use 3 different sources, and they can't all be the internet/wikipedia
    wikipedia has the best everything
    google is an amazing tool for finding information (when you know what to look for)
        site:example.com
        "find text containing exactly this quote"
    kind of annoying when
    privacy! google is no good! degoogle!
    duckduckgo sucks for most things compared to google, but can be better sometimes
    searxng - now i get google, duckduck, and many more all in one - better than every search engine individuallyt!

ai - i remember the day chatgpt began making the rounds on hacker news
    fall 2022: ai just made a huge impressive breakthrough, but only for spam and chatbots
    2023: ai is neat but not for programming
        early github copilot automates blindly copy pasting from random stack overflow
        using ai for programming will only lead to useless information and hallucinations
    late fall 2023: ai is an essential everyday tool for search and 
        it is at this point that information/research and ai merge
        ai search engines

ai 2.0
    many of my google search queries can be answered much better with ai
    google/metasearch: best internet full text search
        i know exactly what i am looking for, and just need to find it
    marginalia.search: best "small" web search tool
        i have a topic in mind that i want to learn more about
        mainstream search engines will only produce seo spam
        marginalia 
    mellisearch?
    perplexity - meh
    kagi - concise, links cited
